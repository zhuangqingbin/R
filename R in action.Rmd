---
title: "R in action"
author: "zhuang"
date: "2016年3月5日"
output: html_document
---

```{r}
#------------------------------------------------------#
# R in Action: Chapter 1                               #
#------------------------------------------------------#

# In the following code q() is commented out so that
# you don't quit the session

# Listing 1.1 - A Sample R session

age <- c(1, 3, 5, 2, 11, 9, 3, 9, 12, 3)
weight <- c(4.4, 5.3, 7.2, 5.2, 8.5, 7.3, 6, 10.4, 10.2, 6.1)
mean(weight)
sd(weight)
cor(age, weight)
plot(age, weight)
# q()

# help.start()  打开帮助文档首页
# help("foo")   或?foo 查看函数foo的帮助（引号可以省略）
# help.search("foo")或??foo 以foo   为关键词搜索本地帮助文档
# example("foo")  函数foo的使用示例（引号可以省略）
# RSiteSearch("foo")   以foo为关键词搜索在线文档和邮件列表存档
# apropos("foo", mode="function")   列出名称中含有foo的所有可用函数
# data()   列出当前已加载包中所含的所有可用示例数据集
# vignette()  列出当前已安装包中所有可用的vignette文档
# vignette("foo")   为主题foo显示指定的vignette文档




# Listing 1.2 - An example of commands used to manage
# the R Workspace. Change the next line to one of your 
# directories

# 工作空间（workspace）就是当前R的工作环境，它储存着所有用户定义的对象（向量、矩阵、函数、数据框、列表） 。在一个R会话结束时，你可以将当前工作空间保存到一个镜像中，并在下次启动R时自动载入它。各种命令可在R命令行中交互式地输入。使用上下方向键查看已输入命令的历史记录。这样我们就可以选择一个之前输入过的命令并适当修改，最后按回车重新执行它。

setwd("C:/myprojects/project1")
options()
options(digits=3)
x <- runif(20)
summary(x)
hist(x)
savehistory()
save.image()
# q()

# Listing 1.3 - Working with a new package

help.start()
install.packages("vcd")
help(package = "vcd")
library(vcd)
help(Arthritis)
Arthritis
example(Arthritis)
# q()


```

```{r}
#--------------------------------------------------------#
# R in Action: Chapter 2                                 #
#--------------------------------------------------------#
  探索R中的数据结构
  输入数据
  导入数据
  标注数据

#  Creating vectors

a <- c(1, 2, 5, 3, 6, -2, 4)
b <- c("one", "two", "three")
c <- c(TRUE, TRUE, TRUE, FALSE, TRUE, FALSE)

# Using vector subscripts 索引

a <- c(1, 2, 5, 3, 6, -2, 4)
a[3]
a[c(1, 3, 5)]
a[2:6]

# Listing 2.1 - Creating Matrices

y <- matrix(1:20, nrow = 5, ncol = 4)
y
cells <- c(1, 26, 24, 68)
rnames <- c("R1", "R2")
cnames <- c("C1", "C2")
mymatrix <- matrix(cells, nrow = 2, ncol = 2, byrow = TRUE, 
    dimnames = list(rnames, cnames))
mymatrix
mymatrix <- matrix(cells, nrow = 2, ncol = 2, byrow = FALSE, 
    dimnames = list(rnames, cnames))
mymatrix

# Listing 2.2 - Using matrix subscripts

x <- matrix(1:10, nrow = 2)
x
x[2, ]
x[, 2]
x[1, 4]
x[1, c(4, 5)]

# Listing 2.3 - Creating an array

dim1 <- c("A1", "A2")
dim2 <- c("B1", "B2", "B3")
dim3 <- c("C1", "C2", "C3", "C4")
z <- array(1:24, c(2, 3, 4), dimnames = list(dim1, 
    dim2, dim3))
z

# Listing 2.4 - Creating a dataframe

patientID <- c(1, 2, 3, 4)
age <- c(25, 34, 28, 52)
diabetes <- c("Type1", "Type2", "Type1", "Type1")
status <- c("Poor", "Improved", "Excellent", "Poor")
patientdata <- data.frame(patientID, age, diabetes, 
    status)
patientdata

# Listing 2.5 - Specifying elements of a dataframe

patientdata[1:2]
patientdata[c("diabetes", "status")]
patientdata$age

# Listing 2.6 - Using factors

patientID <- c(1, 2, 3, 4)
age <- c(25, 34, 28, 52)
diabetes <- c("Type1", "Type2", "Type1", "Type1")
status <- c("Poor", "Improved", "Excellent", "Poor")
diabetes <- factor(diabetes)
status <- factor(status, order = TRUE)
patientdata <- data.frame(patientID, age, diabetes, 
    status)
str(patientdata)
summary(patientdata)

#  Listing 2.7 - Creating a list

g <- "My First List"
h <- c(25, 26, 18, 39)
j <- matrix(1:10, nrow = 5)
k <- c("one", "two", "three")
mylist <- list(title = g, ages = h, j, k)
mylist

```


```{r}
#-----------------------------------------------------#
# R in Action: Chapter 3                              #
# requires that the Hmisc package has been installed  #
# install.packages('Hmisc')                           #
#-----------------------------------------------------#

# pause after each graph
par(ask = TRUE)

# --Section 3.1--

attach(mtcars)
plot(wt, mpg)
abline(lm(mpg ~ wt))
title("Regression of MPG on Weight")
detach(mtcars)

# --Section 3.2--

dose <- c(20, 30, 40, 45, 60)
drugA <- c(16, 20, 27, 40, 60)
drugB <- c(15, 18, 25, 31, 40)
plot(dose, drugA, type = "b")

# --Section 3.3--

opar <- par(no.readonly = TRUE)
par(lty = 2, pch = 17)
plot(dose, drugA, type = "b")
par(opar)

plot(dose, drugA, type = "b", lty = 2, pch = 17)
plot(dose, drugA, type = "b", lyt = 3, lwd = 3, pch = 15, 
    cex = 2)

n <- 10
mycolors <- rainbow(n)
pie(rep(1, n), labels = mycolors, col = mycolors)
mygrays <- gray(0:n/n)
pie(rep(1, n), labels = mygrays, col = mygrays)

# Listing 3.1 - Using graphical parameters to control
# graph appearance

dose <- c(20, 30, 40, 45, 60)
drugA <- c(16, 20, 27, 40, 60)
drugB <- c(15, 18, 25, 31, 40)
opar <- par(no.readonly = TRUE)
par(pin = c(2, 3))
par(lwd = 2, cex = 1.5)
par(cex.axis = 0.75, font.axis = 3)
plot(dose, drugA, type = "b", pch = 19, lty = 2, col = "red")
plot(dose, drugB, type = "b", pch = 23, lty = 6, col = "blue", bg = "green")
par(opar)

# --Section 3.4--

plot(dose, drugA, type = "b", col = "red", lty = 2, 
    pch = 2, lwd = 2, main = "Clinical Trials for Drug A", 
    sub = "This is hypothetical data", 
    xlab = "Dosage", ylab = "Drug Response", xlim = c(0, 60), 
    ylim = c(0, 70))


# Listing 3.2 - An Example of Custom Axes

x <- c(1:10)
y <- x
z <- 10/x
opar <- par(no.readonly = TRUE)
par(mar = c(5, 4, 4, 8) + 0.1)

plot(x, y, type = "b", pch = 21, col = "red", yaxt = "n", 
    lty = 3, ann = FALSE)
lines(x, z, type = "b", pch = 22, col = "blue", lty = 2)
axis(2, at = x, labels = x, col.axis = "red", las = 2)
axis(4, at = z, labels = round(z, digits = 2), col.axis = "blue", 
    las = 2, cex.axis = 0.7, tck = -0.01)
mtext("y=1/x", side = 4, line = 3, cex.lab = 1, las = 2, 
    col = "blue")
title("An Example of Creative Axes", xlab = "X values", 
    ylab = "Y=X")
par(opar)

# Listing 3.3 - Comparing Drug A and Drug B response by dose

dose <- c(20, 30, 40, 45, 60)
drugA <- c(16, 20, 27, 40, 60)
drugB <- c(15, 18, 25, 31, 40)
opar <- par(no.readonly = TRUE)
par(lwd = 2, cex = 1.5, font.lab = 2)
plot(dose, drugA, type = "b", pch = 15, lty = 1, col = "red", 
    ylim = c(0, 60), main = "Drug A vs. Drug B", xlab = "Drug Dosage", 
    ylab = "Drug Response")
lines(dose, drugB, type = "b", pch = 17, lty = 2, 
    col = "blue")
abline(h = c(30), lwd = 1.5, lty = 2, col = "grey")
library(Hmisc)
minor.tick(nx = 3, ny = 3, tick.ratio = 0.5)
legend("topleft", inset = 0.05, title = "Drug Type", 
    c("A", "B"), lty = c(1, 2), pch = c(15, 17), col = c("red", 
        "blue"))
par(opar)

# --Section 3.4.5--

# Example of labeling points

attach(mtcars)
plot(wt, mpg, main = "Milage vs. Car Weight", xlab = "Weight", 
    ylab = "Mileage", pch = 18, col = "blue")
text(wt, mpg, row.names(mtcars), cex = 0.6, pos = 4, 
    col = "red")
detach(mtcars)

# View font families
opar <- par(no.readonly = TRUE)
par(cex = 1.5)
plot(1:7, 1:7, type = "n")
text(3, 3, "Example of default text")
text(4, 4, family = "mono", "Example of mono-spaced text")
text(5, 5, family = "serif", "Example of serif text")
par(opar)

# --Section 3.5--

# combining graphs

# Figure 3.14
attach(mtcars)
opar <- par(no.readonly = TRUE)
par(mfrow = c(2, 2))
plot(wt, mpg, main = "Scatterplot of wt vs. mpg")
plot(wt, disp, main = "Scatterplot of wt vs disp")
hist(wt, main = "Histogram of wt")
boxplot(wt, main = "Boxplot of wt")
par(opar)
detach(mtcars)

# Figure 3.15
attach(mtcars)
opar <- par(no.readonly = TRUE)
par(mfrow = c(3, 1))
hist(wt)
hist(mpg)
hist(disp)
par(opar)
detach(mtcars)

# Figure 3.16
attach(mtcars)
layout(matrix(c(1, 1, 2, 3), 2, 2, byrow = TRUE))
hist(wt)
hist(mpg)
hist(disp)
detach(mtcars)

# Figure 3.17
attach(mtcars)
layout(matrix(c(1, 1, 2, 3), 2, 2, byrow = TRUE), 
    widths = c(3, 1), heights = c(1, 2))
hist(wt)
hist(mpg)
hist(disp)
detach(mtcars)

# Listing 3.4 - Fine placement of figures in a graph

opar <- par(no.readonly = TRUE)
par(fig = c(0, 0.8, 0, 0.8))
plot(mtcars$wt, mtcars$mpg, xlab = "Miles Per Gallon", 
    ylab = "Car Weight")
par(fig = c(0, 0.8, 0.55, 1), new = TRUE)
boxplot(mtcars$wt, horizontal = TRUE, axes = FALSE)
par(fig = c(0.65, 1, 0, 0.8), new = TRUE)
boxplot(mtcars$mpg, axes = FALSE)
mtext("Enhanced Scatterplot", side = 3, outer = TRUE, 
    line = -3)
par(opar)


```

```{r}
#---------------------------------------------------------#
# R in Action: Chapter 4                                  #
# requires that the reshape and sqldf packages have       #
# been installed                                          #
# install.packages(c('reshape', 'sqldf'))                 #
#---------------------------------------------------------#

# Listing 4.1 - Creating the leadership data frame

manager <- c(1, 2, 3, 4, 5)
date <- c("10/24/08", "10/28/08", "10/1/08", "10/12/08", 
    "5/1/09")
gender <- c("M", "F", "F", "M", "F")
age <- c(32, 45, 25, 39, 99)
q1 <- c(5, 3, 3, 3, 2)
q2 <- c(4, 5, 5, 3, 2)
q3 <- c(5, 2, 5, 4, 1)
q4 <- c(5, 5, 5, NA, 2)
q5 <- c(5, 5, 2, NA, 1)
leadership <- data.frame(manager, date, gender, age, 
    q1, q2, q3, q4, q5, stringsAsFactors = FALSE)
    
# the individual vectors are no longer needed
rm(manager, date, gender, age, q1, q2, q3, q4, q5)

# Listing 4.2 - Creating new variables

mydata <- data.frame(x1 = c(2, 2, 6, 4), x2 = c(3, 
    4, 2, 8))
mydata$sumx <- mydata$x1 + mydata$x2
mydata$meanx <- (mydata$x1 + mydata$x2)/2

attach(mydata)
mydata$sumx <- x1 + x2
mydata$meanx <- (x1 + x2)/2
detach(mydata)

mydata <- transform(mydata, sumx = x1 + x2, meanx = (x1 + 
    x2)/2)

# --Section 4.3--

# Recoding variables

leadership$agecat[leadership$age > 75] <- "Elder"
leadership$agecat[leadership$age > 45 & 
    leadership$age <= 75] <- "Middle Aged"
leadership$agecat[leadership$age <= 45] <- "Young"

# or more compactly

leadership <- within(leadership, {
    agecat <- NA
    agecat[age > 75] <- "Elder"
    agecat[age >= 55 & age <= 75] <- "Middle Aged"
    agecat[age < 55] <- "Young"
})

# --Section 4.4--

# Renaming variables with the reshape package
library(reshape)
rename(leadership, c(manager = "managerID", date = "testDate"))

# --Section 4.5--

# Applying the is.na() function
is.na(leadership[, 6:10])

# recode 99 to missing for the variable age
leadership[leadership$age == 99, "age"] <- NA
leadership

# Using na.omit() to delete incomplete observations
newdata <- na.omit(leadership)
newdata

# --Section 4.6--

mydates <- as.Date(c("2007-06-22", "2004-02-13"))

# Converting character values to dates

strDates <- c("01/05/1965", "08/16/1975")
dates <- as.Date(strDates, "%m/%d/%Y")

myformat <- "%m/%d/%y"
leadership$date <- as.Date(leadership$date, myformat)

# Useful date functions

Sys.Date()
date()

today <- Sys.Date()
format(today, format = "%B %d %Y")
format(today, format = "%A")

# Calculations with with dates

startdate <- as.Date("2004-02-13")
enddate <- as.Date("2009-06-22")
days <- enddate - startdate

# Date functions and formatted printing

today <- Sys.Date()
format(today, format = "%B %d %Y")
dob <- as.Date("1956-10-10")
format(dob, format = "%A")

# --Section 4.7--

# Listing 4.5 - Converting from one data type to another

a <- c(1, 2, 3)
a
is.numeric(a)
is.vector(a)
a <- as.character(a)
a
is.numeric(a)
is.vector(a)
is.character(a)

# --Section 4.8--

# Sorting a dataset

attach(leadership)
newdata <- leadership[order(age), ]
newdata
detach(leadership)

attach(leadership)
newdata <- leadership[order(gender, -age), ]
newdata
detach(leadership)

# -- Section 4.10--

# Selecting variables

newdata <- leadership[, c(6:10)]

myvars <- c("q1", "q2", "q3", "q4", "q5")
newdata <- leadership[myvars]

myvars <- paste("q", 1:5, sep = "")
newdata <- leadership[myvars]

# Dropping variables

myvars <- names(leadership) %in% c("q3", "q4")
newdata <- leadership[!myvars]

newdata <- leadership[c(-7, -8)]

# You could use the following to delete q3 and q4
# from the leadership dataset (commented out so 
# the rest of the code in this file will work)
#
# leadership$q3 <- leadership$q4 <- NULL

# Selecting observations

# Listing 4.6 - Selecting Observations

newdata <- leadership[1:3, ]

newdata <- leadership[which(leadership$gender == "M" & 
    leadership$age > 30), ]

attach(leadership)
newdata <- leadership[which(leadership$gender == "M" & 
    leadership$age > 30), ]
detach(leadership)

# Selecting observations based on dates

leadership$date <- as.Date(leadership$date, "%m/%d/%y")
startdate <- as.Date("2009-01-01")
enddate <- as.Date("2009-10-31")
newdata <- leadership[leadership$date >= startdate & 
    leadership$date <= enddate, ]

# Using the subset() function

newdata <- subset(leadership, age >= 35 | age < 24, 
    select = c(q1, q2, q3, q4))
newdata <- subset(leadership, gender == "M" & age > 
    25, select = gender:q4)

# --Section 4.11--

# Listing 4.7 - Using SQL statements to manipulate data frames

library(sqldf)
newdf <- sqldf("select * from mtcars where carb=1 order by mpg", 
    row.names = TRUE)
newdf <- sqldf("select avg(mpg) as avg_mpg, avg(disp) as avg_disp,
    gear from mtcars where cyl in (4, 6) group by gear")
    
```

```{r}
#----------------------------------------------------#
# R in Action: Chapter 5                             #
#----------------------------------------------------#

# Listing 5.1 -  Calculating the mean and 
# standard deviation

x <- c(1, 2, 3, 4, 5, 6, 7, 8)
mean(x)
sd(x)
n <- length(x)
meanx <- sum(x)/n
css <- sum((x - meanx)**2)            
sdx <- sqrt(css / (n-1))
meanx
sdx

# Listing 5.2 - Generating pseudo-random numbers from 
# a uniform distribution

runif(5)
runif(5)
set.seed(1234)                                                     
runif(5)
set.seed(1234)                                                      
runif(5)

# Listing 5.3 - Generating data from a multivariate 
# normal distribution

library(MASS)
options(digits=3)
set.seed(1234)

mean <- c(230.7, 146.7, 3.6)                                           
sigma <- matrix( c(15360.8, 6721.2, -47.1,                              
                    6721.2, 4700.9, -16.5,
                     -47.1,  -16.5,   0.3), nrow=3, ncol=3)

mydata <- mvrnorm(500, mean, sigma)                                     
mydata <- as.data.frame(mydata)                                         
names(mydata) <- c("y", "x1", "x2")                                       

dim(mydata)                                                             
head(mydata, n=10)   

# Listing 5.4 - Applying functions to data objects

a <- 5
sqrt(a)
b <- c(1.243, 5.654, 2.99)
round(b)
c <- matrix(runif(12), nrow=3)
c
log(c)
mean(c)

# Listing 5.5 - Applying a function to the rows 
# (columns) of a matrix

mydata <- matrix(rnorm(30), nrow=6)
mydata
apply(mydata, 1, mean)     
apply(mydata, 2, mean) 
apply(mydata, 2, mean, trim=.4)   

# Listing 5.6 - A solution to the learning example

options(digits=2)

Student <- c("John Davis", "Angela Williams", 
    "Bullwinkle Moose", "David Jones", 
    "Janice Markhammer", "Cheryl Cushing",
    "Reuven Ytzrhak", "Greg Knox", "Joel England",
    "Mary Rayburn")
Math <- c(502, 600, 412, 358, 495, 512, 410, 625, 573, 522)
Science <- c(95, 99, 80, 82, 75, 85, 80, 95, 89, 86)
English <- c(25, 22, 18, 15, 20, 28, 15, 30, 27, 18)
roster <- data.frame(Student, Math, Science, English,
    stringsAsFactors=FALSE)
    
z <- scale(roster[,2:4]) 
score <- apply(z, 1, mean)                                            
roster <- cbind(roster, score)

y <- quantile(score, c(.8,.6,.4,.2))                                   
roster$grade[score >= y[1]] <- "A"                                     
roster$grade[score < y[1] & score >= y[2]] <- "B"
roster$grade[score < y[2] & score >= y[3]] <- "C"
roster$grade[score < y[3] & score >= y[4]] <- "D"
roster$grade[score < y[4]] <- "F"

name <- strsplit((roster$Student), " ")                                
lastname <- sapply(name, "[", 2)
firstname <- sapply(name, "[", 1)

roster <- cbind(firstname,lastname, roster[,-1])
roster <- roster[order(lastname,firstname),]

roster

# Listing 5.7 - A switch example

feelings <- c("sad", "afraid")
for (i in feelings)
    print(
      switch(i,
             happy  = "I am glad you are happy",
             afraid = "There is nothing to fear",
             sad    = "Cheer up",
             angry  = "Calm down now"
    )
  )
  
# Listing 5.8 - mystats(): a user-written function 
# for summary statistics

mystats <- function(x, parametric=TRUE, print=FALSE) {
  if (parametric) {
    center <- mean(x); spread <- sd(x) 
  } else {
    center <- median(x); spread <- mad(x) 
  }
  if (print & parametric) {
    cat("Mean=", center, "\n", "SD=", spread, "\n")
  } else if (print & !parametric) {
    cat("Median=", center, "\n", "MAD=", spread, "\n")
  }
  result <- list(center=center, spread=spread)
  return(result)
}

# trying it out
set.seed(1234)
x <- rnorm(500) 
y <- mystats(x)
y <- mystats(x, parametric=FALSE, print=TRUE)

# Another switch example
mydate <- function(type="long") {
    switch(type,
    long =  format(Sys.time(), "%A %B %d %Y"), 
    short = format(Sys.time(), "%m-%d-%y"),
    cat(type, "is not a recognized type\n"))
}
mydate("long")
mydate("short")
mydate()
mydate("medium")

# Listing 5.9 - Transposing a dataset

cars <- mtcars[1:5, 1:4]      
cars
t(cars)

# Listing 5.10 - Aggregating data

options(digits=3)
attach(mtcars)
aggdata <-aggregate(mtcars, by=list(cyl,gear), 
    FUN=mean, na.rm=TRUE)
aggdata

```

```{r}
#----------------------------------------------------------------#
# R in Action: Chapter 6                                         #
# requires that the vcd, plotrix, sm, vioplot packages have been #
# installed                                                      #
# install.packages(c('vcd', 'plotrix', 'sm', 'vioplot'))         #
#----------------------------------------------------------------#

# pause after each graph
par(ask = TRUE)

# save original graphic settings
opar <- par(no.readonly = TRUE)

# Load vcd package
library(vcd)

# Get cell counts for improved variable
counts <- table(Arthritis$Improved)
counts

# Listing 6.1 - Simple bar plot

# simple bar plot
barplot(counts, main = "Simple Bar Plot", xlab = "Improvement", 
    ylab = "Frequency")

# horizontal bar plot
barplot(counts, main = "Horizontal Bar Plot", xlab = "Frequency", 
    ylab = "Improvement", horiz = TRUE)


# get counts for Improved by Treatment table
counts <- table(Arthritis$Improved, Arthritis$Treatment)
counts

# Listing 6.2 - Stacked and groupde bar plots

# stacked barplot
barplot(counts, main = "Stacked Bar Plot", xlab = "Treatment", 
    ylab = "Frequency", col = c("red", "yellow", "green"), 
    legend = rownames(counts))

# grouped barplot
barplot(counts, main = "Grouped Bar Plot", xlab = "Treatment", 
    ylab = "Frequency", col = c("red", "yellow", "green"), 
    legend = rownames(counts), 
    beside = TRUE)


# Listing 6.3 - Mean bar plots

states <- data.frame(state.region, state.x77)
means <- aggregate(states$Illiteracy, 
    by = list(state.region), 
    FUN = mean)
means

means <- means[order(means$x), ]
means

barplot(means$x, names.arg = means$Group.1)
title("Mean Illiteracy Rate")

# Listing 6.4 - Fitting labels in bar plots

par(mar = c(5, 8, 4, 2))
par(las = 2)
counts <- table(Arthritis$Improved)

barplot(counts, main = "Treatment Outcome", horiz = TRUE, 
    cex.names = 0.8, names.arg = c("No Improvement", 
    "Some Improvement", "Marked Improvement"))

# Section --6.1.5 Spinograms--

library(vcd)
attach(Arthritis)
counts <- table(Treatment, Improved)
spine(counts, main = "Spinogram Example")
detach(Arthritis)


# Listing 6.5 - Pie charts

par(mfrow = c(2, 2))
slices <- c(10, 12, 4, 16, 8)
lbls <- c("US", "UK", "Australia", "Germany", "France")

pie(slices, labels = lbls, main = "Simple Pie Chart")

pct <- round(slices/sum(slices) * 100)
lbls2 <- paste(lbls, " ", pct, "%", sep = "")
pie(slices, labels = lbls2, col = rainbow(length(lbls)), 
    main = "Pie Chart with Percentages")

library(plotrix)
pie3D(slices, labels = lbls, explode = 0.1, main = "3D Pie Chart ")

mytable <- table(state.region)
lbls <- paste(names(mytable), "\n", mytable, sep = "")
pie(mytable, labels = lbls, 
    main = "Pie Chart from a Table\n (with sample sizes)")

# restore original graphic parameters
par(opar)

# fan plots
library(plotrix)
slices <- c(10, 12, 4, 16, 8)
lbls <- c("US", "UK", "Australia", "Germany", "France")
fan.plot(slices, labels = lbls, main = "Fan Plot")


# Listing 6.6 - Histograms

par(mfrow = c(2, 2))

hist(mtcars$mpg)

hist(mtcars$mpg, breaks = 12, col = "red", 
    xlab = "Miles Per Gallon", 
    main = "Colored histogram with 12 bins")

hist(mtcars$mpg, freq = FALSE, breaks = 12, col = "red", 
    xlab = "Miles Per Gallon", 
    main = "Histogram, rug plot, density curve")
rug(jitter(mtcars$mpg))
lines(density(mtcars$mpg), col = "blue", lwd = 2)

# Histogram with Superimposed Normal Curve 
# (Thanks to Peter Dalgaard)
x <- mtcars$mpg
h <- hist(x, breaks = 12, col = "red", 
    xlab = "Miles Per Gallon", 
    main = "Histogram with normal curve and box")
xfit <- seq(min(x), max(x), length = 40)
yfit <- dnorm(xfit, mean = mean(x), sd = sd(x))
yfit <- yfit * diff(h$mids[1:2]) * length(x)
lines(xfit, yfit, col = "blue", lwd = 2)
box()

# restore original graphic parameters
par(opar)

# Listing 6.7 - Kernel density plot

par(mfrow = c(2, 1))
d <- density(mtcars$mpg)

plot(d)

d <- density(mtcars$mpg)
plot(d, main = "Kernel Density of Miles Per Gallon")
polygon(d, col = "red", border = "blue")
rug(mtcars$mpg, col = "brown")

# restore original graphic parameters
par(opar)

# Listing 6.8 - Comparing kernel density plots

par(lwd = 2)
library(sm)
attach(mtcars)

cyl.f <- factor(cyl, levels = c(4, 6, 8), 
    labels = c("4 cylinder", "6 cylinder", "8 cylinder"))

sm.density.compare(mpg, cyl, xlab = "Miles Per Gallon")
title(main = "MPG Distribution by Car Cylinders")

colfill <- c(2:(2 + length(levels(cyl.f))))
cat("Use mouse to place legend...", "\n\n")
legend(locator(1), levels(cyl.f), fill = colfill)
detach(mtcars)
par(lwd = 1)

# --Section 6.5--

boxplot(mpg ~ cyl, data = mtcars, 
    main = "Car Milage Data", 
    xlab = "Number of Cylinders", 
    ylab = "Miles Per Gallon")

boxplot(mpg ~ cyl, data = mtcars, notch = TRUE, 
    varwidth = TRUE, col = "red", 
    main = "Car Mileage Data", 
    xlab = "Number of Cylinders", 
    ylab = "Miles Per Gallon")

# Listing 6.9 - Box plots for two crossed factors

mtcars$cyl.f <- factor(mtcars$cyl, levels = c(4, 6, 
    8), labels = c("4", "6", "8"))

mtcars$am.f <- factor(mtcars$am, levels = c(0, 1), 
    labels = c("auto", "standard"))

boxplot(mpg ~ am.f * cyl.f, data = mtcars, 
    varwidth = TRUE, col = c("gold", "darkgreen"), 
    main = "MPG Distribution by Auto Type", 
    xlab = "Auto Type")

# Listing 6.10 - Violin plots

library(vioplot)
x1 <- mtcars$mpg[mtcars$cyl == 4]
x2 <- mtcars$mpg[mtcars$cyl == 6]
x3 <- mtcars$mpg[mtcars$cyl == 8]
vioplot(x1, x2, x3, 
    names = c("4 cyl", "6 cyl", "8 cyl"), 
    col = "gold")
title("Violin Plots of Miles Per Gallon")

# --Section 6.6--

dotchart(mtcars$mpg, labels = row.names(mtcars), 
    cex = 0.7, 
    main = "Gas Milage for Car Models", 
    xlab = "Miles Per Gallon")

# Listing 6.11 - sorted colored grouped dot chart

x <- mtcars[order(mtcars$mpg), ]
x$cyl <- factor(x$cyl)
x$color[x$cyl == 4] <- "red"
x$color[x$cyl == 6] <- "blue"
x$color[x$cyl == 8] <- "darkgreen"
dotchart(x$mpg, labels = row.names(x), cex = 0.7, 
    pch = 19, groups = x$cyl, 
    gcolor = "black", color = x$color, 
    main = "Gas Milage for Car Models\ngrouped by cylinder", 
    xlab = "Miles Per Gallon")
    
```

```{r}
#--------------------------------------------------------------------#
# R in Action: Chapter 7                                             #
# requires that the npmc, ggm, gmodels, vcd, Hmisc,                  #
# pastecs, psych, doBy, and reshape packages have been installed     #
# install.packages(c('npmc', 'ggm', 'gmodels', 'vcd', 'Hmisc',       #
#     'pastecs', 'psych', 'doBy', 'reshape'))                        #
#---------------------------------------------------------------------

vars <- c("mpg", "hp", "wt")
head(mtcars[vars])

# Listing 7.1 - descriptive stats via summary

summary(mtcars[vars])

# Listing 7.2 - descriptive stats via sapply()

mystats <- function(x, na.omit = FALSE) {
    if (na.omit) 
        x <- x[!is.na(x)]
    m <- mean(x)
    n <- length(x)
    s <- sd(x)
    skew <- sum((x - m)^3/s^3)/n
    kurt <- sum((x - m)^4/s^4)/n - 3
    return(c(n = n, mean = m, stdev = s, skew = skew, kurtosis = kurt))
}

sapply(mtcars[vars], mystats)

# Listing 7.3 - Descriptive statistics (Hmisc package)

library(Hmisc)
describe(mtcars[vars])

# Listing 7.4 - Descriptive statistics (pastecs package)

library(pastecs)
stat.desc(mtcars[vars])

# Listing 7.5 - Descriptive statistics (psych package)

library(psych)
describe(mtcars[vars])

# Listing 7.6 - Descriptive statistics by group with aggregate()

aggregate(mtcars[vars], by = list(am = mtcars$am), mean)
aggregate(mtcars[vars], by = list(am = mtcars$am), sd)

# Listing 7.7 - Descriptive statistics by group via by()

dstats <- function(x)(c(mean=mean(x), sd=sd(x)))
by(mtcars[vars], mtcars$am, dstats)

# Listing 7.8 Summary statists by group (doBy package)

library(doBy)
summaryBy(mpg + hp + wt ~ am, data = mtcars, FUN = mystats)

# Listing 7.9 - Summary statistics by group (psych package)

library(psych)
describe.by(mtcars[vars], mtcars$am)

# Listing 1.10 Summary statistics by group (reshape package)

library(reshape)
dstats <- function(x) (c(n = length(x), mean = mean(x), 
    sd = sd(x)))
dfm <- melt(mtcars, measure.vars = c("mpg", "hp", 
    "wt"), id.vars = c("am", "cyl"))
cast(dfm, am + cyl + variable ~ ., dstats)

# Section --7.2--

# get Arthritis data
library(vcd)

# one way table

mytable <- with(Arthritis, table(Improved))
mytable
prop.table(mytable)
prop.table(mytable)*100


# two way table

mytable <- xtabs(~ Treatment+Improved, data=Arthritis)
mytable
margin.table(mytable, 1)
prop.table(mytable, 1)
margin.table(mytable, 2)
prop.table(mytable, 2)
prop.table(mytable)
addmargins(mytable)
admargins(prop.table(mytable))
addmargins(prop.table(mytable, 1), 2)
addmargins(prop.table(mytable, 2, 1)

# Listing 7.11 - Two-way table using CrossTable

library(gmodels)
CrossTable(Arthritis$Treatment, Arthritis$Improved)

# Listing 7.12 - Three-way contingency table

mytable <- xtabs(~ Treatment+Sex+Improved, data=Arthritis)
mytable
ftable(mytable)
margin.table(mytable, 1)
margin.table(mytable, 2)
margin.table(mytable, 3)
margin.table(mytable, c(1,3))
ftable(prop.table(mytable, c(1, 2)))
ftable(addmargins(prop.table(mytable, c(1, 2)), 3))

gtable(addmargins(prop.table(mytable, c(1, 2)), 3)) * 100

# Listing 7.13 - Chis-square test of independence

library(vcd)
mytable <- xtabs(~Treatment+Improved, data=Arthritis)
chisq.test(mytable)
mytable <- xtabs(~Improved+Sex, data=Arthritis)
chisq.test(mytable)

# Fisher's exact test

mytable <- xtabs(~Treatment+Improved, data=Arthritis)
fisher.test(mytable)

# Chochran-Mantel-Haenszel test

mytable <- xtabs(~Treatment+Improved+Sex, data=Arthritis)
mantelhaen.test(mytable)

# Listing 7.14 - Measures of association for a two-way table

library(vcd)
mytable <- xtabs(~Treatment+Improved, data=Arthritis)
assocstats(mytable)


# Listing 7.15 - converting a table into a flat file via table2flat

table2flat <- function(mytable) {
    df <- as.data.frame(mytable)
    rows <- dim(df)[1]
    cols <- dim(df)[2]
    x <- NULL
    for (i in 1:rows) {
        for (j in 1:df$Freq[i]) {
            row <- df[i, c(1:(cols - 1))]
            x <- rbind(x, row)
        }
    }
    row.names(x) <- c(1:dim(x)[1])
    return(x)
}

# Listing 7.16 - Using table2flat with published data

treatment <- rep(c("Placebo", "Treated"), 3)
improved <- rep(c("None", "Some", "Marked"), each = 2)
Freq <- c(29, 13, 7, 7, 7, 21)
mytable <- as.data.frame(cbind(treatment, improved, Freq))
mydata <- table2flat(mytable)
head(mydata)

# Listing 7.17 - Covariances and correlations

states <- state.x77[, 1:6]
cov(states)
cor(states)
cor(states, method="spearman")

x <- states[, c("Population", "Income", "Illiteracy", "HS Grad")]
y <- states[, c("Life Exp", "Murder")]
cor(x, y)

# partial correlation of population and murder rate, controlling
# for income, illiteracy rate, and HS graduation rate

library(ggm)
pcor(c(1, 5, 2, 3, 6), cov(states))

# Listing 7.18 - Testing correlations for significance

cor.test(states[, 3], states[, 5])

# Listing 7.19 - Correlation matrix and tests of significance via corr.test

library(psych)
corr.test(states, use = "complete")

# --Section 7.4--

# independent t-test

library(MASS)
t.test(Prob ~ So, data=UScrime)

# dependent t-test

library(MASS)
sapply(UScrime[c("U1", "U2")], function(x) (c(mean = mean(x), 
    sd = sd(x))))
with(UScrime, t.test(U1, U2, paired = TRUE))

# --Section 7.5--

# Wilcoxon two group comparison

with(UScrime, by(Prob, So, median))
wilcox.test(Prob ~ So, data=UScrime)
sapply(UScrime[c("U1", "U2")], median)
with(UScrime, wilcox.test(U1, U2, paired = TRUE))

# Kruskal Wallis test

states <- as.data.frame(cbind(state.region, state.x77))
kruskal.test(Illiteracy ~ state.region, data=states)

# Listing 7.20 - Nonparametric multiple comparisons

class <- state.region
var <- state.x77[, c("Illiteracy")]
mydata <- as.data.frame(cbind(class, var))
rm(class,var)
library(npmc)
summary(npmc(mydata), type = "BF")
aggregate(mydata, by = list(mydata$class), median)

```

```{r}
#------------------------------------------------------------------------#
# R in Action: Chapter 8                                                 #
# requires that the car, gvlma, MASS, leaps packages have been installed #
# install.packages(c('car', 'gvlma', 'MASS', 'leaps'))                   #
#------------------------------------------------------------------------#

# pause on each graph
par(ask = TRUE)

# save current graphical parameters
opar <- par(no.readonly = TRUE)

# Listing 8.1 - simple linear regression

fit <- lm(weight ~ height, data = women)
summary(fit)
women$weight
fitted(fit)
residuals(fit)

# scatter plot of height by weight

plot(women$height, women$weight, main = "Women Age 30-39", 
    xlab = "Height (in inches)", ylab = "Weight (in pounds)")
# add the line of best fit
abline(fit)

# Listing 8.2 - Polynomial regression

fit2 <- lm(weight ~ height + I(height^2), data = women)
summary(fit2)

plot(women$height, women$weight, main = "Women Age 30-39", 
    xlab = "Height (in inches)", ylab = "Weight (in lbs)")
lines(women$height, fitted(fit2))

# scatterplot for women data

library(car)
scatterplot(weight ~ height, data = women, spread = FALSE, 
    lty.smooth = 2, pch = 19, main = "Women Age 30-39", xlab = "Height (inches)", 
    ylab = "Weight (lbs.)")

# Listing 8.3 - Examining bivariate relationship

states <- as.data.frame(state.x77[, c("Murder", "Population", 
    "Illiteracy", "Income", "Frost")])
    
cor(states)

library(car)
scatterplotMatrix(states, spread = FALSE, lty.smooth = 2, 
    main = "Scatterplot Matrix")
    
# Listing 8.4 - Multiple linear regression

fit <- lm(Murder ~ Population + Illiteracy + Income + 
    Frost, data = states)
    
# Listing 8.5 Multiple linear regression with a significant
# interaction term

fit <- lm(mpg ~ hp + wt + hp:wt, data = mtcars)
summary(fit)

library(effects)
plot(effect("hp:wt", fit, list(wt = c(2.2, 3.2, 4.2))), 
    multiline = TRUE)
    
# --Section 8.3--

fit <- lm(Murder ~ Population + Illiteracy + Income +
    Frost, data=states)
confint(fit)

# simple regression diagnostics

fit <- lm(weight ~ height, data = women)
par(mfrow = c(2, 2))
plot(fit)
par(opar)

# regression diagnostics for quadratic fit

newfit <- lm(weight ~ height + I(height^2), data = women)
par(mfrow = c(2, 2))
plot(newfit)
par(opar)

# regression diagnostics for quadratic fit 
# with deleted observations

newfit <- lm(weight ~ height + I(height^2), data = women[-c(13, 15),])
par(mfrow = c(2, 2))
plot(newfit)
par(opar)

# basic regression diagnostics for states data

fit <- lm(Murder ~ Population + Illiteracy + Income + 
    Frost, data = states)
par(mfrow = c(2, 2))
plot(fit)
par(opar)

# Assessing normality
library(car)
fit <- lm(Murder ~ Population + Illiteracy + Income + 
    Frost, data = states)
qqPlot(fit, labels = FALSE, simulate = TRUE, main = "Q-Q Plot")


# Listing 8.6 Function for plotting studentized residuals

residplot <- function(fit, nbreaks=10) {
    z <- rstudent(fit)
    hist(z, breaks=nbreaks, freq=FALSE,
    xlab="Studentized Residual",
    main="Distribution of Errors")
    rug(jitter(z), col="brown")
    curve(dnorm(x, mean=mean(z), sd=sd(z)),
        add=TRUE, col="blue", lwd=2)
    lines(density(z)$x, density(z)$y,
        col="red", lwd=2, lty=2)
    legend("topright",
        legend = c( "Normal Curve", "Kernel Density Curve"),
        lty=1:2, col=c("blue","red"), cex=.7)
}

residplot(fit)

#  Durbin Watson test for Autocorrelated Errors

durbinWatsonTest(fit)

# Component + Residual Plots

crPlots(fit, one.page = TRUE, ask = FALSE)

# Listing 8.7 - Assessing homoscedasticity

library(car)
ncvTest(fit)
spreadLevelPlot(fit)

# Listing 8.8 - Global test of linear model assumptions

library(gvlma)
gvmodel <- gvlma(fit)
summary(gvmodel)

# Library 8.9 - Evaluating multi-collinearity

vif(fit)
sqrt(vif(fit)) > 2

# --Section 8.4--

# Assessing outliers

library(car)
outlierTest(fit)

# Index plot of hat values
# use the mouse to identify points interactively

hat.plot <- function(fit){
    p <- length(coefficients(fit))
    n <- length(fitted(fit))
    plot(hatvalues(fit), main = "Index Plot of Hat Values")
    abline(h = c(2, 3) * p/n, col = "red", lty = 2)
    identify(1:n, hatvalues(fit), names(hatvalues(fit)))
}

hat.plot(fit)

# Cook's D Plot
# identify D values > 4/(n-k-1)

cutoff <- 4/(nrow(states) - length(fit$coefficients) - 2)
plot(fit, which = 4, cook.levels = cutoff)
abline(h = cutoff, lty = 2, col = "red")

# Added variable plots
# use the mouse to identify points interactively

avPlots(fit, ask = FALSE, onepage = TRUE, id.method = "identify")

# Influence Plot
# use the mouse to identify points interactively

influencePlot(fit, id.method = "identify", main = "Influence Plot", 
    sub = "Circle size is proportial to Cook's Distance")

# Listing 8.10 - Box-Cox Transformation to normality

library(car)
summary(powerTransform(states$Murder))

# Box-Tidwell Transformations to Linearity

library(car)
boxTidwell(Murder ~ Population + Illiteracy, data = states)

# Listing 8.11 - Comparing nested models using the anova function

fit1 <- lm(Murder ~ Population + Illiteracy + Income + 
    Frost, data = states)
fit2 <- lm(Murder ~ Population + Illiteracy, data = states)
anova(fit2, fit1)

# Listing 8.12 - Comparing models with the Akaike Information Criterion

fit1 <- lm(Murder ~ Population + Illiteracy + Income + 
    Frost, data = states)
fit2 <- lm(Murder ~ Population + Illiteracy, data = states)
AIC(fit1, fit2)

# Listing 8.13 - Backward stepwise selection

library(MASS)
fit1 <- lm(Murder ~ Population + Illiteracy + Income + 
    Frost, data = states)
stepAIC(fit, direction = "backward")

# Listing 8.14 - All subsets regression
# use the mouse to place the legend interactively 
# in the second plot

library(leaps)
leaps <- regsubsets(Murder ~ Population + Illiteracy + 
    Income + Frost, data = states, nbest = 4)
plot(leaps, scale = "adjr2")

library(car)
subsets(leaps, statistic = "cp", 
    main = "Cp Plot for All Subsets Regression")
abline(1, 1, lty = 2, col = "red")

# Listing 8.15 - Function for k-fold cross-validated R-square
shrinkage <- function(fit, k = 10) {
    require(bootstrap)
    # define functions
    theta.fit <- function(x, y) {
        lsfit(x, y)
    }
    theta.predict <- function(fit, x) {
        cbind(1, x) %*% fit$coef
    }
    
    # matrix of predictors
    x <- fit$model[, 2:ncol(fit$model)]
    # vector of predicted values
    y <- fit$model[, 1]
    
    results <- crossval(x, y, theta.fit, theta.predict, ngroup = k)
    r2 <- cor(y, fit$fitted.values)^2
    r2cv <- cor(y, results$cv.fit)^2
    cat("Original R-square =", r2, "\n")
    cat(k, "Fold Cross-Validated R-square =", r2cv, "\n")
    cat("Change =", r2 - r2cv, "\n")
}

# using shrinkage()

fit <- lm(Murder ~ Population + Income + Illiteracy + 
    Frost, data = states)
shrinkage(fit)

fit2 <- lm(Murder ~ Population + Illiteracy, data = states)
shrinkage(fit2)

#  Calculating standardized regression coefficients
zstates <- as.data.frame(scale(states))
zfit <- lm(Murder ~ Population + Income + Illiteracy + 
    Frost, data = zstates)
coef(zfit)

# Listing 8.16 - relweights() function for calculating relative
# importance of predictors

########################################################################
# The relweights function determines the relative importance of each   #
# independent variable to the dependent variable in an OLS regression. #
# The code is adapted from an SPSS program generously provided by      #
# Dr. Johnson.                                                         #
#                                                                      #
# See Johnson (2000, Multivariate Behavioral Research, 35, 1-19) for   #
# an explanation of how the relative weights are derived.              #
########################################################################
relweights <- function(fit, ...) {
    R <- cor(fit$model)
    nvar <- ncol(R)
    rxx <- R[2:nvar, 2:nvar]
    rxy <- R[2:nvar, 1]
    svd <- eigen(rxx)
    evec <- svd$vectors
    ev <- svd$values
    delta <- diag(sqrt(ev))
    
    # correlations between original predictors and new orthogonal variables
    lambda <- evec %*% delta %*% t(evec)
    lambdasq <- lambda^2
    
    # regression coefficients of Y on orthogonal variables
    beta <- solve(lambda) %*% rxy
    rsquare <- colSums(beta^2)
    rawwgt <- lambdasq %*% beta^2
    import <- (rawwgt/rsquare) * 100
    lbls <- names(fit$model[2:nvar])
    rownames(import) <- lbls
    colnames(import) <- "Weights"
    
    # plot results
    barplot(t(import), names.arg = lbls, ylab = "% of R-Square", 
        xlab = "Predictor Variables", main = "Relative Importance of Predictor Variables", 
        sub = paste("R-Square = ", round(rsquare, digits = 3)), 
        ...)
    return(import)
}

# using relweights()

fit <- lm(Murder ~ Population + Illiteracy + Income + 
    Frost, data = states)
relweights(fit, col = "lightgrey")
```

```{r}
#------------------------------------------------------------------ #
# R in Action: Chapter 9                                            #
# requires that the multcomp, gplots, car, HH, effects,             #
#     rrcov, mvoutlier, MASS packages have been installed           #
# install.packages(c('multcomp', 'gplots', 'car', 'HH', 'effects',  #
#     'rrcov', 'mvoutlier', 'MASS'))                                #
#-------------------------------------------------------------------#

# pause for each graph
par(ask = TRUE)

# save original graphical parameters
opar <- par(no.readonly = TRUE)

# Listing 9.1 - One-way ANOVA

library(multcomp)
attach(cholesterol)
table(trt)
aggregate(response, by = list(trt), FUN = mean)
aggregate(response, by = list(trt), FUN = sd)
fit <- aov(response ~ trt)
summary(fit)
library(gplots)
plotmeans(response ~ trt, xlab = "Treatment", ylab = "Response", 
    main = "Mean Plot\nwith 95% CI")
detach(cholesterol)

# Listing 9.2 - Tukey HSD pairwise group comparisons

TukeyHSD(fit)
par(las = 2)
par(mar = c(5, 8, 4, 2))
plot(TukeyHSD(fit))
par(opar)

# Multiple comparisons the multcomp package

library(multcomp)
par(mar = c(5, 4, 6, 2))
tuk <- glht(fit, linfct = mcp(trt = "Tukey"))
plot(cld(tuk, level = 0.05), col = "lightgrey")
par(opar)

# Assessing normality

library(car)
qqPlot(lm(response ~ trt, data = cholesterol), simulate = TRUE, 
    main = "QQ Plot", labels = FALSE)

# Assessing homogeneity of variances

bartlett.test(response ~ trt, data = cholesterol)

# Assessing outliers

library(car)
outlierTest(fit)

# Listing 9.3 - One-way ANCOVA

data(litter, package = "multcomp")
attach(litter)
table(dose)
aggregate(weight, by = list(dose), FUN = mean)
fit <- aov(weight ~ gesttime + dose)
summary(fit)

# Obtaining adjusted means

library(effects)
effect("dose", fit)

# Listing 9.4 - Multiple comparisons using user supplied contrasts

library(multcomp)
contrast <- rbind(`no drug vs. drug` = c(3, -1, -1, -1))
summary(glht(fit, linfct = mcp(dose = contrast)))

# Listing 9.5 - Testing for Homegeneity of Regression Slopes

library(multcomp)
fit2 <- aov(weight ~ gesttime * dose)
summary(fit2)

# Visualizing a one-way ANCOVA

library(HH)
ancova(weight ~ gesttime + dose, data = litter)

# Listing 9.6 - Two way ANOVA

attach(ToothGrowth)
table(supp, dose)
aggregate(len, by = list(supp, dose), FUN = mean)
aggregate(len, by = list(supp, dose), FUN = sd)
fit <- aov(len ~ supp * dose)
summary(fit)

# plotting interactions

interaction.plot(dose, supp, len, type = "b", col = c("red", 
    "blue"), pch = c(16, 18), 
    main = "Interaction between Dose and Supplement Type")
    
library(gplots)
plotmeans(len ~ interaction(supp, dose, sep = " "), 
    connect = list(c(1, 3, 5), c(2, 4, 6)), 
    col = c("red", "darkgreen"), 
    main = "Interaction Plot with 95% CIs", 
    xlab = "Treatment and Dose Combination")
    
library(HH)
interaction2wt(len ~ supp * dose)

# Listing 9.7 - Repeated measures ANOVA with one between 
# and within groups factor

w1b1 <- subset(CO2, Treatment == "chilled")
fit <- aov(uptake ~ (conc * Type) + Error(Plant/(conc)), 
    w1b1)
summary(fit)

par(las = 2)
par(mar = c(10, 4, 4, 2))
with(w1b1, interaction.plot(conc, Type, uptake, type = "b", 
    col = c("red", "blue"), pch = c(16, 18), main = "Interaction Plot for Plant Type and Concentration"))
boxplot(uptake ~ Type * conc, data = w1b1, col = (c("gold", 
    "green")), main = "Chilled Quebec and Mississippi Plants", 
    ylab = "Carbon dioxide uptake rate (umol/m^2 sec)")
par(opar)

# Listing 9.8 - One-way MANOVA

library(MASS)
attach(UScereal)
y <- cbind(calories, fat, sugars)
aggregate(y, by = list(shelf), FUN = mean)
cov(y)
fit <- manova(y ~ shelf)
summary(fit)
summary.aov(fit)

# Listing 9.9 - Assessing multivariate normality
# identify points interactively with the mouse

center <- colMeans(y)
n <- nrow(y)
p <- ncol(y)
cov <- cov(y)
d <- mahalanobis(y, center, cov)
coord <- qqplot(qchisq(ppoints(n), df = p), d, main = "QQ Plot Assessing Multivariate Normality", 
    ylab = "Mahalanobis D2")
abline(a = 0, b = 1)
identify(coord$x, coord$y, labels = row.names(UScereal))

# multivariate outliers
library(mvoutlier)
outliers <- aq.plot(y)
outliers

# Listing 9.10 - Robust one-way MANOVA
# this may take a while...

library(rrcov)
Wilks.test(y, shelf, method = "mcd")

# Listing 9.11 - A regression approach to the ANOVA
# problem in section 9.3

fit.lm <- lm(response ~ trt, data=cholesterol)
summary(fit.lm)

contrasts(cholesterol$trt)
```

```{r}
#--------------------------------------------------#
# R in Action: Chapter 10                          #
# requires that the pwr package has been installed #
# install.packages('pwr')                          #
#--------------------------------------------------#

# pause on each graph
par(ask = TRUE)

# load required package
library(pwr)

# t tests

pwr.t.test(d = 0.8, sig.level = 0.05, power = 0.9, 
    type = "two.sample", alternative = "two.sided")

pwr.t.test(n = 20, d = 0.5, sig.level = 0.01, 
    type = "two.sample", 
    alternative = "two.sided")

# ANOVA

pwr.anova.test(k = 5, f = 0.25, sig.level = 0.05, 
    power = 0.8)

# Correlations

pwr.r.test(r = 0.25, sig.level = 0.05, power = 0.9, 
    alternative = "greater")

# Linear Models

pwr.f2.test(u = 3, f2 = 0.0769, sig.level = 0.05, 
    power = 0.9)

# Tests of proportions
pwr.2p.test(h = ES.h(0.65, 0.6), sig.level = 0.05, 
    power = 0.9, alternative = "greater")

# Chi-square tests

prob <- matrix(c(0.42, 0.28, 0.03, 0.07, 0.1, 0.1), 
    byrow = TRUE, nrow = 3)
ES.w2(prob)
pwr.chisq.test(w = 0.1853, df = 3, sig.level = 0.05, 
    power = 0.9)

# Listing 10.1 - Sample sizes for detecting significant
# effects in a One-Way ANOVA

es <- seq(0.1, 0.5, 0.01)
nes <- length(es)
samsize <- NULL
for (i in 1:nes) {
    result <- pwr.anova.test(k = 5, f = es[i], 
        sig.level = 0.05, 
        power = 0.9)
    samsize[i] <- ceiling(result$n)
}
plot(samsize, es, type = "l", lwd = 2, col = "red", 
    ylab = "Effect Size", xlab = "Sample Size (per cell)", 
    main = "One Way ANOVA with Power=.90 and Alpha=.05")

# Listing 10.2 - Sample size curves for dtecting corelations
# of various sizes

library(pwr)
r <- seq(0.1, 0.5, 0.01)
nr <- length(r)
p <- seq(0.4, 0.9, 0.1)
np <- length(p)
samsize <- array(numeric(nr * np), dim = c(nr, np))
for (i in 1:np) {
    for (j in 1:nr) {
        result <- pwr.r.test(n = NULL, r = r[j], sig.level = 0.05, 
            power = p[i], alternative = "two.sided")
        samsize[j, i] <- ceiling(result$n)
    }
}
xrange <- range(r)
yrange <- round(range(samsize))
colors <- rainbow(length(p))
plot(xrange, yrange, type = "n", 
    xlab = "Correlation Coefficient (r)", 
    ylab = "Sample Size (n)")
for (i in 1:np) {
    lines(r, samsize[, i], type = "l", lwd = 2, col = colors[i])
}
abline(v = 0, h = seq(0, yrange[2], 50), lty = 2, 
    col = "grey89")
abline(h = 0, v = seq(xrange[1], xrange[2], 0.02), 
    lty = 2, col = "grey89")
title("Sample Size Estimation for Correlation Studies\nSig=0.05 (Two-tailed)")
legend("topright", title = "Power", as.character(p), 
    fill = colors)


```

```{r}
#-------------------------------------------------------------------------#
# R in Action: Chapter 11                                                 #
# requires that the car, scatterplot3d, gclus, hexbin, IDPmisc, Hmisc,    #
#     corrgram, vcd, rgl, and Rcmdr packages have been installed          #
# install.packages(c("car", "scatterplot3d", "gclus", "hexbin",           #  
#      "IDPmisc", "Hmisc", "corrgram", "vcd", "rgl", "Rcmdr"))            #
#-------------------------------------------------------------------------#

# pause on each graph
par(ask=TRUE)

# save original graphical parameter settings
opar <- par(no.readonly=TRUE) # record current settings

# Listing 11.1 - A scatterplot with best fit lines

attach(mtcars)                                                     
plot(wt, mpg, 
     main="Basic Scatterplot of MPG vs. Weight",       
     xlab="Car Weight (lbs/1000)", 
     ylab="Miles Per Gallon ", pch=19)
abline(lm(mpg ~ wt), col="red", lwd=2, lty=1)            
lines(lowess(wt, mpg), col="blue", lwd=2, lty=2)   

# enhanced scatterplot
# identify points interactively with the mouse

library(car) 
scatterplot(mpg ~ wt | cyl, data=mtcars, lwd=2,
    main="Scatter Plot of MPG vs. Weight by # Cylinders", 
    xlab="Weight of Car (lbs/1000)", 
    ylab="Miles Per Gallon", id.method="identify",
    legend.plot=TRUE, labels=row.names(mtcars), 
    boxplots="xy")


# scatterplot matrices

pairs(~ mpg + disp + drat + wt, data=mtcars, 
      main="Basic Scatterplot Matrix")
   
library(car)
scatterplotMatrix(~ mpg + disp + drat + wt, data=mtcars, spread=FALSE,
    lty.smooth=2, main="Scatterplot Matrix via car package")
scatterplotMatrix(~ mpg + disp + drat + wt | cyl, data=mtcars, spread=FALSE,
    main="Scatterplot Matrix via car package", diagonal="histogram")

cor(mtcars[c("mpg", "wt", "disp", "drat")])

# Listing 11-2 Scatter plot matrix produced with the gclus package

library(gclus)                                                   
mydata <- mtcars[c(1,3,5,6)]                               
mydata.corr <- abs(cor(mydata))                                                                           
mycolors <- dmat.color(mydata.corr)                              
myorder <- order.single(mydata.corr)                             
cpairs(mydata,                                                   
    myorder, 
    panel.colors=mycolors, 
    gap=.5,
    main="Variables Ordered and Colored by Correlation"
)

# high density scatterplots

set.seed(1234)
n <- 10000
c1 <- matrix(rnorm(n, mean=0, sd=.5), ncol=2)
c2 <- matrix(rnorm(n, mean=3, sd=2), ncol=2)
mydata <- rbind(c1, c2)
mydata <- as.data.frame(mydata)
names(mydata) <- c("x", "y")

with(mydata,
    plot(x, y, pch=19, main="Scatter Plot with 10000 Observations"))

with(mydata,
    smoothScatter(x, y, main="Scatterplot colored by Smoothed Densities"))

library(hexbin)
with(mydata, {
    bin <- hexbin(x, y, xbins=50)
    plot(bin, main="Hexagonal Binning with 10,000 Observations")
    })

library(IDPmisc)
with(mydata,
    iplot(x, y, main="Image Scatter Plot with Color Indicating Density"))
par(opar)

# 3-D Scatterplots

library(scatterplot3d)
attach(mtcars)
scatterplot3d(wt, disp, mpg, 
     main="Basic 3D Scatterplot")
 
scatterplot3d(wt, disp, mpg, 
    pch=16, 
    highlight.3d=TRUE,
    type="h",
    main="3D Scatterplot with Vertical Lines")

s3d <-scatterplot3d(wt, disp, mpg, 
    pch=16, 
    highlight.3d=TRUE,
    type="h", 
    main="3D Scatter Plot with Verical Lines and Regression Plane")
fit <- lm(mpg ~ wt+disp) 
s3d$plane3d(fit)
detach(mtcars)

# spinning 3D plot

library(rgl)
attach(mtcars)
plot3d(wt, disp, mpg, col="red", size=5)

# alternative
rgl.open()
library(Rcmdr)
attach(mtcars)
scatter3d(wt, disp, mpg)


# bubble plots

attach(mtcars)
r <- sqrt(disp/pi)
symbols(wt, mpg, r, inches=0.30, fg="white", bg="lightblue",
main="Bubble Plot with point size proportional to displacement",
ylab="Miles Per Gallon",
xlab="Weight of Car (lbs/1000)")
text(wt, mpg, rownames(mtcars), cex=0.6)
detach(mtcars)
par(opar)

# Listing 11.3 - Creating side by side scatter and line plots

par(mfrow=c(1,2))
t1 <- subset(Orange, Tree==1)
plot(t1$age, t1$circumference,
    xlab="Age (days)", 
    ylab="Circumference (mm)", 
    main="Orange Tree 1 Growth")
plot(t1$age, t1$circumference,
    xlab="Age (days)",
    ylab="Circumference (mm)",
    main="Orange Tree 1 Growth", 
    type="b")
par(opar)

# Listing 11.4 -  Line chart displaying the growth of 
# 5 Orange trees over time

Orange$Tree <- as.numeric(Orange$Tree)      
ntrees <- max(Orange$Tree)

xrange <- range(Orange$age)                 
yrange <- range(Orange$circumference)        

plot(xrange, yrange,                        
    type="n",                               
    xlab="Age (days)",                      
    ylab="Circumference (mm)"               
 )                                          

colors <- rainbow(ntrees)                   
linetype <- c(1:ntrees)                     
plotchar <- seq(18, 18+ntrees, 1)           

for (i in 1:ntrees) {                       
    tree <- subset(Orange, Tree==i)          
    lines(tree$age, tree$circumference,      
        type="b",                           
        lwd=2,                              
        lty=linetype[i],                     
        col=colors[i],                      
        pch=plotchar[i]                     
    )                                       
}                                            

title("Tree Growth", "example of line plot")

legend(xrange[1], yrange[2],                
    1:ntrees,                                
    cex=0.8,                                
    col=colors,                             
    pch=plotchar,                           
    lty=linetype,                           
    title="Tree"                            
    )                                           

# Correlograms

options(digits=2)
cor(mtcars)

library(corrgram)
corrgram(mtcars, order=TRUE, lower.panel=panel.shade,
    upper.panel=panel.pie, text.panel=panel.txt,
    main="Correlogram of mtcar intercorrelations")

corrgram(mtcars, order=TRUE, lower.panel=panel.ellipse,
    upper.panel=panel.pts, text.panel=panel.txt,
    diag.panel=panel.minmax, 
    main="Correlogram of mtcar data using scatterplots and ellipses")
    
corrgram(mtcars, lower.panel=panel.shade,
    upper.panel=NULL, text.panel=panel.txt,
    main="Car Mileage Data (unsorted)")

col.corrgram <- function(ncol){   
    colorRampPalette(c("darkgoldenrod4", "burlywood1",
                                     "darkkhaki", "darkgreen"))(ncol)} 
corrgram(mtcars, order=TRUE, lower.panel=panel.shade, 
    upper.panel=panel.pie, text.panel=panel.txt, 
    main="A Corrgram (or Horse) of a Different Color")


# Mosaic Plots

ftable(Titanic)
library(vcd)
mosaic(Titanic, shade=TRUE, legend=TRUE)

# Figure 11.18
# type= options in the plot() and lines() functions

x <- c(1:5)
y <- c(1:5)
par(mfrow=c(2,4))
types <- c("p", "l", "o", "b", "c", "s", "S", "h")
for (i in types){
    plottitle <- paste("type=", i)
    plot(x,y,type=i, col="red", lwd=2, cex=1, main=plottitle)
}


```

```{r}
#------------------------------------------------------------#
# R in Action: Chapter 12                                    #
# requires that the coin, multcomp, vcd, MASS,               # 
#     lmPerm, and boot packages have been installed          #
# install.packages(c('coin','multcomp', 'vcd', 'MASS',       # 
#    'lmPerm', 'boot'))                                      #
#------------------------------------------------------------#

# Listing 12.1 - t-test vs. oneway permutation test for the 
# hypothetical data in table 12.1

library(coin)
score <- c(40, 57, 45, 55, 58, 57, 64, 55, 62, 65)
treatment <- factor(c(rep("A", 5), rep("B", 5)))
mydata <- data.frame(treatment, score)
t.test(score ~ treatment, data = mydata, var.equal = TRUE)
oneway_test(score ~ treatment, data = mydata, distribution = "exact")

# Wilcoxon Mann-Whitney U test

library(MASS)
UScrime <- transform(UScrime, So = factor(So))
wilcox_test(Prob ~ So, data = UScrime, distribution = "exact")

# k sample test

library(multcomp)
oneway_test(response ~ trt, data = cholesterol, 
    distribution = approximate(B = 9999))

# independence in contingency tables

library(coin)
library(vcd)
Arthritis <- transform(Arthritis, 
    Improved = as.factor(as.numeric(Improved)))
set.seed(1234)
chisq_test(Treatment ~ Improved, data = Arthritis, 
    distribution = approximate(B = 9999))

# independence between numeric variables

states <- as.data.frame(state.x77)
set.seed(1234)
spearman_test(Illiteracy ~ Murder, data = states, 
    distribution = approximate(B = 9999))


# dependent 2-sample and k-sample tests

library(coin)
library(MASS)
wilcoxsign_test(U1 ~ U2, data = UScrime, 
    distribution = "exact")

# Listing 12.2 - Permutation tests for simple linear regression

library(lmPerm)
set.seed(1234)
fit <- lmp(weight ~ height, data = women, perm = "Prob")
summary(fit)

# Listing 12.3 - Permutation tests for polynomial regression

library(lmPerm)
set.seed(1234)
fit <- lmp(weight ~ height + I(height^2), data = women, perm = "Prob")
summary(fit)

# Listing 12.4 - Permutation tests for multiple regression

library(lmPerm)
set.seed(1234)
states <- as.data.frame(state.x77)
fit <- lmp(Murder ~ Population + Illiteracy + 
    Income + Frost, data = states, perm = "Prob")
summary(fit)

# Listing 12.5 - Permutation test for One-Way ANOVA

library(lmPerm)
library(multcomp)
set.seed(1234)
fit <- aovp(response ~ trt, data = cholesterol, 
    perm = "Prob")
summary(fit)

#  Listing 12.6 - Permutation test for One-Way ANCOVA

library(lmPerm)
set.seed(1234)
fit <- aovp(weight ~ gesttime + dose, data = litter, 
    perm = "Prob")
summary(fit)

# Listing 12.7 - Permutation test for Two-way ANOVA

library(lmPerm)
set.seed(1234)
fit <- aovp(len ~ supp * dose, data = ToothGrowth, 
    perm = "Prob")
summary(fit)


# bootstrapping a single statistic (R2)

# pause on each graph
par(ask = TRUE)

rsq <- function(formula, data, indices) {
    d <- data[indices, ]
    fit <- lm(formula, data = d)
    return(summary(fit)$r.square)
}

library(boot)
set.seed(1234)
results <- boot(data = mtcars, statistic = rsq, 
    R = 1000, formula = mpg ~ wt + disp)
print(results)
plot(results)
boot.ci(results, type = c("perc", "bca"))

# bootstrapping several statistics 
# (regression coefficients)


bs <- function(formula, data, indices) {
    d <- data[indices, ]
    fit <- lm(formula, data = d)
    return(coef(fit))
}

library(boot)
set.seed(1234)
results <- boot(data = mtcars, statistic = bs, 
    R = 1000, formula = mpg ~ wt + disp)
print(results)
plot(results, index = 2)
boot.ci(results, type = "bca", index = 2)

```

```{r}
#--------------------------------------------------#
# R in Action: Chapter 13                          #
# requires that the AER, robust, and qcc packages  #
#    have been installed                           #
# install.packages(c('AER', 'robust', 'qcc'))      #
#--------------------------------------------------#

# --Logistic Regression--

# get summary statistics
data(Affairs, package = "AER")
summary(Affairs)
table(Affairs$affairs)

# create binary outcome variable
Affairs$ynaffair[Affairs$affairs > 0] <- 1
Affairs$ynaffair[Affairs$affairs == 0] <- 0
Affairs$ynaffair <- factor(Affairs$ynaffair, levels = c(0, 
    1), labels = c("No", "Yes"))
table(Affairs$ynaffair)

# fit full model
fit.full <- glm(ynaffair ~ gender + age + yearsmarried + 
    children + religiousness + education + occupation + rating, 
    data = Affairs, family = binomial())
summary(fit.full)

# fit reduced model
fit.reduced <- glm(ynaffair ~ age + yearsmarried + 
    religiousness + rating, data = Affairs, family = binomial())
summary(fit.reduced)

# compare models
anova(fit.reduced, fit.full, test = "Chisq")

# interpret coefficients
coef(fit.reduced)
exp(coef(fit.reduced))

# calculate probability of extramariatal affair by marital ratings
testdata <- data.frame(rating = c(1, 2, 3, 4, 5), 
    age = mean(Affairs$age), yearsmarried = mean(Affairs$yearsmarried), 
    religiousness = mean(Affairs$religiousness))
testdata$prob <- predict(fit.reduced, newdata = testdata, 
    type = "response")
testdata

# calculate probabilites of extramariatal affair by age
testdata <- data.frame(rating = mean(Affairs$rating), 
    age = seq(17, 57, 10), yearsmarried = mean(Affairs$yearsmarried), 
    religiousness = mean(Affairs$religiousness))
testdata$prob <- predict(fit.reduced, newdata = testdata, 
    type = "response")
testdata

# evaluate overdispersion
fit <- glm(ynaffair ~ age + yearsmarried + religiousness + 
    rating, family = binomial(), data = Affairs)
fit.od <- glm(ynaffair ~ age + yearsmarried + religiousness + 
    rating, family = quasibinomial(), data = Affairs)
pchisq(summary(fit.od)$dispersion * fit$df.residual, 
    fit$df.residual, lower = F)


# --Poisson Regression--

# look at dataset
data(breslow.dat, package = "robust")
names(breslow.dat)
summary(breslow.dat[c(6, 7, 8, 10)])

# plot distribution of post-treatment seizure counts
opar <- par(no.readonly = TRUE)
par(mfrow = c(1, 2))
attach(breslow.dat)
hist(sumY, breaks = 20, xlab = "Seizure Count", main = "Distribution of Seizures")
boxplot(sumY ~ Trt, xlab = "Treatment", main = "Group Comparisons")
par(opar)

# fit regression
fit <- glm(sumY ~ Base + Age + Trt, data = breslow.dat, 
    family = poisson())
summary(fit)

# interpret model parameters
coef(fit)
exp(coef(fit))

# evaluate overdispersion
library(qcc)
qcc.overdispersion.test(breslow.dat$sumY, type = "poisson")

# fit model with quasipoisson
fit.od <- glm(sumY ~ Base + Age + Trt, data = breslow.dat, 
    family = quasipoisson())
summary(fit.od)

```

```{r}
#------------------------------------------- #
# R in Action: Chapter 14                    #
# requires that the psych has been installed #
# install.packages(c('psych'))               #
#------------------------------------------- #

# pause on each graph
par(ask = TRUE)

set.seed(1234)

# determine number of components in USJudgeRatings
library(psych)
fa.parallel(USJudgeRatings[, -1], fa = "pc", ntrials = 100, 
    show.legend = FALSE, main = "Scree plot with parallel analysis")

# Listing 14.1 - Principal components anaalysis of US Judge Ratings

pc <- principal(USJudgeRatings[, -1], nfactors = 1, score = TRUE)
pc

# determine number of components in Harman data
library(psych)
fa.parallel(Harman23.cor$cov, n.obs=302, fa="pc", ntrials=100,
    show.legend=FALSE, main="Scree plot with parallel analysis")
    
# Listing 14.2 Pricnicapl components analysis of body measurements

library(psych)
fa.parallel(Harman23.cor$cov, n.obs = 302, fa = "pc", 
    ntrials = 100, show.legend = FALSE, 
    main = "Scree plot with parallel analysis")
pc <- principal(Harman23.cor$cov, nfactors = 2, rotate = "none")
pc

# Listing 14.3 Principal components analysis with varimax rotation

rc <- principal(Harman23.cor$cov, nfactors = 2, rotate = "varimax")
rc

# Listing 14.4 - Obtaining component scores from raw data

library(psych)
pc <- principal(USJudgeRatings[,-1], nfactors=1, score=TRUE)
head(pc$scores)

# correlation between PC score and number of lawyer contacts
cor(USJudgeRatings$CONT, pc$score)

# Listing 14.5 - Obtaining principal component scroing coefficients

library(psych)
rc <- principal(Harman23.cor$cov, nfactors=2, rotate="varimax")
round(unclass(rc$weights), 2)

# Exploratory factor analysis of ability.cov data

options(digits = 2)
library(psych)
covariances <- ability.cov$cov
# convert covariances to correlations
correlations <- cov2cor(covariances)
correlations

# determine number of factors to extract
fa.parallel(correlations, n.obs = 112, fa = "both", 
    ntrials = 100, main = "Scree plots with parallel analysis")

# Listing 14.6 - Principal axis factoring without rotation

fa <- fa(correlations, nfactors = 2, rotate = "none", fm = "pa")
fa

# Listing 14.7 - Factor extraction with orthogonal rotation

fa.varimax <- fa(correlations, nfactors = 2, rotate = "varimax", 
    fm = "pa")
fa.varimax

# Listing 14.8 - Factor extraction with oblique rotation

fa.promax <- fa(correlations, nfactors = 2, rotate = "promax", 
    fm = "pa")
fa.promax

# Calculate factor loading matrix

fsm <- function(oblique) {
    if (class(oblique)[2]=="fa" & is.null(oblique$Phi)) {
        warning("Object doesn't look like oblique EFA")
    } else {
        P <- unclass(oblique$loading)
        F <- P %*% oblique$Phi
        colnames(F) <- c("PA1", "PA2")
        return(F)
    }
}

fsm(fa.promax)

# plot factor solution

factor.plot(fa.promax, labels = rownames(fa.promax$loadings))
fa.diagram(fa.promax, simple = FALSE)

```

```{r}
#-------------------------------------------------------------#
# R in Action: Chapter 15                                     #
# requires that the VIM and mice packages have been installed #
# install.packages(c('VIM', 'mice'))                          #
#-------------------------------------------------------------#

# pause on each graph
par(ask = TRUE)

# load the dataset
data(sleep, package = "VIM")

# list the rows that do not have missing values
sleep[complete.cases(sleep), ]

# list the rows that have one or more missing values
sleep[!complete.cases(sleep), ]

# number of missing values on Dream
sum(is.na(sleep$Dream))

# percent of cases with missing values on Dream
mean(is.na(sleep$Dream))

# percent of cases with one or missing values
mean(!complete.cases(sleep))

# tabulate missing values patters
library(mice)
md.pattern(sleep)

# plot missing values patterns
library("VIM")
# close GUI window
aggr(sleep, prop = FALSE, numbers = TRUE)
matrixplot(sleep) # use mouse to sort columns, STOP to move on
marginplot(sleep[c("Gest", "Dream")], pch = c(20), 
    col = c("darkgray", "red", "blue"))

# use correlations to explore missing values
x <- as.data.frame(abs(is.na(sleep)))
head(sleep, n=5)
head(x, n=5)
y <- x[which(sd(x) > 0)]
cor(y)
cor(sleep, y, use = "pairwise.complete.obs")

# complete case analysis (listwise deletion)
cor(na.omit(sleep))
fit <- lm(Dream ~ Span + Gest, data = na.omit(sleep))
summary(fit)

# multiple imputation
library(mice)
data(sleep, package = "VIM")
imp <- mice(sleep, seed = 1234)
fit <- with(imp, lm(Dream ~ Span + Gest))
pooled <- pool(fit)
summary(pooled)
imp
dataset3 <- complete(imp, action=3)
dataset3

# pairwise deletion
cor(sleep, use="pairwise.complete.obs")

```

```{r}
#--------------------------------------------------------------------#
# R in Action: Chapter 16                                            #
# requires that the ggplot2, playwith, iplots, and                   #                
#     latticist packages are intalled                                #
# install.packages(c('ggplot2', 'playwith', 'latticist', 'iplots'))  #
#--------------------------------------------------------------------#

# to avoid confusion, the playwith, latticist and iplots examples
# should be run separately

# pause for each graph
par(ask = TRUE)

# the lattice package
library(lattice)
histogram(~height | voice.part, data = singer, 
    main = "Distribution of Heights by Voice Pitch", 
    xlab = "Height (inches)")

# Listing 16.1 - Lattice plot examples

library(lattice)
attach(mtcars)

gear <- factor(gear, levels = c(3, 4, 5), 
    labels = c("3 gears", "4 gears", "5 gears"))

cyl <- factor(cyl, levels = c(4, 6, 8), 
    labels = c("4 cylinders", 6 cylinders", "8 cylinders"))

densityplot(~mpg, 
    main = "Density Plot", xlab = "Miles per Gallon")

densityplot(~mpg | cyl, 
    main = "Density Plot by Number of Cylinders", 
    xlab = "Miles per Gallon")

bwplot(cyl ~ mpg | gear, 
    main = "Box Plots by Cylinders and Gears", 
    xlab = "Miles per Gallon", ylab = "Cylinders")

xyplot(mpg ~ wt | cyl * gear, 
    main = "Scatter Plots by Cylinders and Gears", 
    xlab = "Car Weight", ylab = "Miles per Gallon")

cloud(mpg ~ wt * qsec | cyl, 
    main = "3D Scatter Plots by Cylinders")

dotplot(cyl ~ mpg | gear, 
    main = "Dot Plots by Number of Gears and Cylinders", 
    xlab = "Miles Per Gallon")

splom(mtcars[c(1, 3, 4, 5, 6)], 
    main = "Scatter Plot Matrix for mtcars Data")

detach(mtcars)

# conditioning on a continuous variable
displacement <- equal.count(mtcars$disp, number = 3, 
    overlap = 0)
xyplot(mpg ~ wt | displacement, data = mtcars, 
    main = "Miles per Gallon vs. Weight by Engine Displacement", 
    xlab = "Weight", ylab = "Mile per Gallon", 
    layout = c(3, 1), aspect = 1.5)

# Listing 16.2 - xyplot with custom panel functions

displacement <- equal.count(mtcars$disp, number = 3, 
    overlap = 0)

mypanel <- function(x, y) {
    panel.xyplot(x, y, pch = 19)
    panel.rug(x, y)
    panel.grid(h = -1, v = -1)
    panel.lmline(x, y, col = "red", lwd = 1, lty = 2)
}

xyplot(mpg ~ wt | displacement, data = mtcars, 
    layout = c(3, 1), aspect = 1.5, 
    main = "Miles per Gallon vs. Weight by Engine Displacement", 
    xlab = "Weight", ylab = "Mile per Gallon", panel = mypanel)

# Listing 16.3 -  xyplot with custom panel functions and additional options

library(lattice)
mtcars$transmission <- factor(mtcars$am, 
    levels = c(0, 1), labels = c("Automatic", "Manual"))

panel.smoother <- function(x, y) {
    panel.grid(h = -1, v = -1)
    panel.xyplot(x, y)
    panel.loess(x, y)
    panel.abline(h = mean(y), lwd = 2, lty = 2, col = "green")
}

xyplot(mpg ~ disp | transmission, data = mtcars, scales = list(cex = 0.8, 
    col = "red"), panel = panel.smoother, xlab = "Displacement", 
    ylab = "Miles per Gallon", 
    main = "MGP vs Displacement by Transmission Type", 
    sub = "Dotted lines are Group Means", aspect = 1)

# grouping variables
library(lattice)
mtcars$transmission <- factor(mtcars$am, levels = c(0, 1), 
    labels = c("Automatic", "Manual"))
densityplot(~mpg, data = mtcars, 
    group = transmission, 
    main = "MPG Distribution by Transmission Type", 
    xlab = "Miles per Gallon", 
    auto.key = TRUE)

# Listing 16.4 - kernel density plot with a group variable and customized legend

library(lattice)
mtcars$transmission <- factor(mtcars$am, levels = c(0, 1), 
    labels = c("Automatic", "Manual"))

colors = c("red", "blue")
lines = c(1, 2)
points = c(16, 17)

key.trans <- list(title = "Trasmission", 
    space = "bottom", columns = 2, 
    text = list(levels(mtcars$transmission)), 
    points = list(pch = points, col = colors), 
    lines = list(col = colors, lty = lines), 
    cex.title = 1, cex = 0.9)

densityplot(~mpg, data = mtcars, 
    group = transmission, 
    main = "MPG Distribution by Transmission Type", 
    xlab = "Miles per Gallon", 
    pch = points, lty = lines, col = colors, 
    lwd = 2, jitter = 0.005, 
    key = key.trans)

# Listing 16.5 -  xyplot with group and conditioning variables and customized legend

library(lattice)
colors <- "darkgreen"
symbols <- c(1:12)
linetype <- c(1:3)

key.species <- list(title = "Plant", 
    space = "right", 
    text = list(levels(CO2$Plant)), 
    points = list(pch = symbols, col = colors))

xyplot(uptake ~ conc | Type * Treatment, data = CO2, 
    group = Plant, 
    type = "o", 
    pch = symbols, col = colors, lty = linetype, 
    main = "Carbon Dioxide Uptake\nin Grass Plants", 
    ylab = expression(paste("Uptake ", 
        bgroup("(", italic(frac("umol", "m"^2)), ")"))), 
    xlab = expression(paste("Concentration ", 
        bgroup("(", italic(frac(mL, L)), ")"))), 
    sub = "Grass Species: Echinochloa crus-galli", 
    key = key.species)

# graphical parameters
show.settings()
mysettings <- trellis.par.get()
mysettings$superpose.symbol
mysettings$superpose.symbol$pch <- c(1:10)
trellis.par.set(mysettings)
show.settings()

# page arrangement
library(lattice)
graph1 <- histogram(~height | voice.part, data = singer, 
    main = "Heights of Choral Singers by Voice Part")
graph2 <- densityplot(~height, data = singer, group = voice.part, 
    plot.points = FALSE, auto.key = list(columns = 4))
plot(graph1, split = c(1, 1, 1, 2))
plot(graph2, split = c(1, 2, 1, 2), newpage = FALSE)

library(lattice)
graph1 <- histogram(~height | voice.part, data = singer, 
    main = "Heights of Choral Singers by Voice Part")
graph2 <- densityplot(~height, data = singer, group = voice.part, 
    plot.points = FALSE, auto.key = list(columns = 4))
plot(graph1, position = c(0, 0.3, 1, 1))
plot(graph2, position = c(0, 0, 1, 0.3), newpage = FALSE)

# --ggplot2--

# box plots example
library(ggplot2)
mtcars$cylinder <- as.factor(mtcars$cyl)
qplot(cylinder, mpg, data=mtcars, geom=c("boxplot", "jitter"),
    fill=cylinder,
    main="Box plots with superimposed data points",
    xlab= "Number of Cylinders",
    ylab="Miles per Gallon")
    
# regression example
library(ggplot2)
transmission <- factor(mtcars$am, levels = c(0, 1), 
    labels = c("Automatic", "Manual"))
qplot(wt, mpg, data = mtcars, 
    color = transmission, shape = transmission, 
    geom = c("point", "smooth"), 
    method = "lm", formula = y ~ x, 
    xlab = "Weight",  ylab = "Miles Per Gallon", 
    main = "Regression Example")

# bubble plot example
library(ggplot2)
mtcars$cyl <- factor(mtcars$cyl, levels = c(4, 6, 8), 
    labels = c("4 cylinders", "6 cylinders", "8 cylinders"))
mtcars$am <- factor(mtcars$am, levels = c(0, 1), 
    labels = c("Automatic", "Manual"))
qplot(wt, mpg, data = mtcars, facets = am ~ cyl, size = hp)

# density plot example
library(ggplot2)
data(singer, package = "lattice")
qplot(height, data = singer, geom = c("density"), 
    facets = voice.part ~ ., fill = voice.part)

# --Interactive graphics examples--
# run the playwith, latticist, and iplots examples separately

# identifying points
plot(mtcars$wt, mtcars$mpg)
identify(mtcars$wt, mtcars$mpg, labels = row.names(mtcars))

# playwith example
library(playwith)
library(lattice)
playwith(xyplot(mpg ~ wt | factor(cyl) * factor(am), 
    data = mtcars, subscripts = TRUE, type = c("r", "p")))

# latticist example
library(latticist)
mtcars$cyl <- factor(mtcars$cyl)
mtcars$gear <- factor(mtcars$gear)
latticist(mtcars, use.playwith=TRUE)

# Listing 16.6 - iplots demonstration

library(iplots)
attach(mtcars)
cylinders <- factor(cyl)
gears <- factor(gear)
transmission <- factor(am)
ihist(mpg)
ibar(gears)
iplot(mpg, wt)
ibox(mtcars[c("mpg", "wt", "qsec", "disp", "hp")])
ipcp(mtcars[c("mpg", "wt", "qsec", "disp", "hp")])
imosaic(transmission, cylinders)
detach(mtcars)

```

```{r}

```

